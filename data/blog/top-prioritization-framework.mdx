---
title: 'top-prioritization-framework'
date: '2024-09-01'
lastmod: '2023-12-10'
tags: ['product', 'feature', 'javascript', 'design-patterns']
summary: 'Modules are crucial components at the center of NestJS. In this post, we will take a closer look at what modules are in NestJS.'
layout: PostSimple
---

import Twemoji from './components/Twemoji';

## Introduction

Feature prioritization is a critical task in product management, where you decide which features or enhancements should be developed and released first based on various factors like value, effort, impact, and alignment with business goals. Effective prioritization ensures that the product development team focuses on the most important features that deliver the highest value to users and the business.

### Why Feature prioritization ?

- **Resource Management**: Development resources (time, budget, people) are often limited, so prioritizing features ensures optimal use of these resources.

- **Strategic Alignment**: Helps ensure that the development work aligns with the company’s strategic goals.

- **User Satisfaction**: By prioritizing features that address the most pressing user needs, you improve user satisfaction and retention.

- **Market Relevance**: Keeps your product competitive by focusing on features that differentiate your product in the market.

### Prioritization frameworks

Feature prioritization frameworks help teams make informed decisions on which features to build, improve, or drop. Here’s a detailed look at some of the most popular frameworks:

1. Value vs Effort Matrix

**Overview**: This matrix helps you prioritize features by comparing their expected value (benefit) against the effort (resources) required to implement them.

Steps:
List Features: Write down all potential features.

- Estimate Value: For each feature, estimate the potential value it will bring to users or the business. Value can be assessed by how well the feature aligns with business goals, user needs, or competitive advantage.
- Estimate Effort: Estimate the effort in terms of time, resources, and complexity to build each feature.
- Plot on the Matrix: Place each feature on a 2x2 matrix where one axis is Value (Low to High) and the other is Effort (Low to High).
  Prioritize:
  High Value, Low Effort(Quick wins): These are quick wins and should be prioritized.
  High Value, High Effort(strategic): Consider these as strategic projects; they may take time but have significant impact.
  Low Value, Low Effort(fill ins): These can be done if resources allow, but they’re not critical,indicating it can be worked on when there’s time available
  Low Value, High Effort(time sinks): These are often not worth pursuing unless necessary for strategic reasons.

![Diagram Module In NestJS](/static/images/blogs/value-vs-effort.png)

Example Features:
Feature A is a quick win, offering high value with low effort.
Feature D is a strategic project, with both high value and high effort.
Feature G is a fill-in, providing low value with minimal effort.
Feature B is a time sink, requiring high effort but offering less value.

![Diagram Module In NestJS](/static/images/blogs/value-vs-eff-example.png)
This matrix helps prioritize which features to tackle first, ensuring that resources are used efficiently to maximize impact. ​​
Pros: Simple and visual; easy to understand.
Cons: Subjective estimates; doesn’t consider user impact in a nuanced way as its subjective estimation ,biased ,Bias Toward Measurable Value ,Overemphasis on Quick Wins

2. Second item
3. Third item
4. Fourth item
5. First item
6. Second item
7. Third item
8. Fourth item
9. Fourth item
10. Fourth item

A module is a class annotated with a `@Module()` decorator. The `@Module()` decorator provides metadata that **Nest** makes use of to organize the application structure:

- Each application has at least one module, a **root module**.
- In **NestJS** modules are strongly recommended as an effective way to organize your components.
- Each module will encapsulate a set of closely related functions.

![Diagram Module In NestJS](/static/images/blogs/module-in-nestjs.png)

The decorator `@Module()` takes a single object whose properties describe the module:

```javascript
// modules/product/product.module.ts
import { Module } from '@nestjs/common';

import CategoryModule from 'modules/category.module'; // Expose route controller.

import ProductController from './product.controller'; // Expose route controller.
import ProductService from './product.service';       // Business Logic
import ProductRepository from './product.repository'; // Data Access

@Module({
  imports: [CategoryModule],
  controllers: [ProductsController],
  providers: [ProductService, ProductRepository],
  exports: [ProductService],
});

export class ProductModule {}
```

- `provider`: The Nest injector will create providers that can be shared within this module at a minimum.
- `controllers`: The set of controllers defined in this module
- `imports`: The list of imported modules that export the providers
- `exports`: The subset of `providers` that are provided by this module and should be available in other modules which import this module.

## Types Of Modules In NestJS

### Feature Module

- A **feature module** simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries.

- To demonstrate this, we'll create the `ProductModule` (responsible for encapsulating Product logic and endpoints).

```javascript
// modules/product/product.module.ts
import { Module } from '@nestjs/common';

import ProductController from './product.controller';
import ProductService from './product.service';

@Module({
  controllers: [ProductController],
  providers: [ProductService],
})
export default class ProductModule {}
```

- The last thing we need to do is import this module into the root module (the `AppModule`, defined in the `app.module.ts` file).

```javascript
// app.module.ts
import { Module } from '@nestjs/common';

import ProductModule from './product/product.module';

@Module({
  imports: [ProductModule],
})
export class AppModule {}
```

### Shared Modules

- In **Nest**, modules are `singletons` (design patterns) by default, and thus you can share the same instance of any provider between multiple modules effortlessly.

- Every module is automatically a **shared module**.

![Diagram Shared Module In NestJS](/static/images/blogs/shared-module.png)

```javascript
// core/logger/logger.module.ts
import { Module } from '@nestjs/common';

import LoggerService from './logger.service';

@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export default class LoggerModule {}
```

```javascript
// modules/product/product.module.ts
import { Module } from '@nestjs/common';

import LoggerModule from 'core/logger/logger.module';

import ProductController from './product.controller';
import ProductService from './product.service';

@Module({
  imports: [LoggerModule],
  controllers: [ProductController],
  providers: [ProductService],
})
export class ProductModule {}

// Import similar LoggerModule for ShopMonitoringModule and PriceMonitoringModule.
```

### Global Modules

- In the showcased example within the **shared module section**, the **LoggerModule** undergoes multiple imports across three distinct modules—namely, **ProductModule, ShopMonitoringModule, and PriceMonitoringModule**.

- This redundancy is both **noticeable and avoidable**. To address this issue, **Nest** offers a feature known as the **Global Module**.

- Rather than importing the **LoggerModule** in each module requiring its functionality, we can simplify the process by importing the **LoggerModule** just once in the **AppModule** (the root module) and applying the `@Global()` decorator to the class, turning it into a **Global Module**.

- This approach significantly reduces redundancy and promotes a more efficient and maintainable code structure.

![Diagram Global Module In NestJS](/static/images/blogs/global-module.png)

- `@Global()` decorator make the module global, that you want to provide a set of providers which should be available everywhere:

```javascript
// core/logger/logger.module.ts
import { Module, Global } from '@nestjs/common';

import LoggerService from './logger.service';

@Global()
@Module({
  providers: [LoggerService],
  exports: [LoggerService],
})
export class LoggerModule {}
```

- Import **LoggerModule** into **AppModule** (root module):

```javascript
// app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

import { LoggerModule } from './core/logger/logger.module';
import { ProductModule } from './modules/product/product.module';
import { ShopMonitoringModule } from './modules/shop-monitoring/shop-monitoring.module';
import { PriceMonitoringModule } from './modules/price-monitoring/price-monitoring.module';

@Module({
  imports: [ProductModule, ShopMonitoringModule, PriceMonitoringModule, LoggerModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

- Using **LoggerService** in **ProductService** (We do not need to import **LoggerModule** into **ProductModule**):

```javascript
// modules/product/product.service.ts
import { Injectable } from '@nestjs/common';

import { LoggerService } from '../../core/logger/logger.service';

@Injectable()
export class ProductService {
  constructor(private logger: LoggerService) {}

  async findAll(): Promise<any> {
    this.logger.log('Get all products');

    return [];
  }
}
```

### Dynamic Modules

- This is a **feature** that allows you to easily create a custom module that can **register and configure providers dynamically**.

- Following is an example of a **dynamic module** definition for a `DatabaseModule`:

```javascript
// core/database/database.providers.ts
import { Connection } from './connection.provider';

import { createConnection, Repository } from 'typeorm'; // Assuming TypeORM for database interaction

export function createDatabaseProviders(options, entities): any[] {
  const providers = entities.map((entity) => ({
    provide: `${entity}Repository`, // Dynamic provider name based on the entity
    useFactory: (connection: Connection) => connection.getRepository(entity),
    inject: [Connection],
  }));

  return [
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async () => {
        const connection = await createConnection({
          ...options,
          entities: entities,
        });
        return connection;
      },
    },
    ...providers, // Include additional providers related to entities
  ];
}
```

```javascript
// core/database/database.module.ts
import { Module, DynamicModule } from '@nestjs/common';

import { createDatabaseProviders } from './database.providers';
import { Connection } from './connection.provider';

@Module({
  providers: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}
```

> **Hint**: The `forRoot()` method may return a _dynamic module_ either synchronously or asynchronously.

- This **module** defines the `Connection` provider by default (in the `@Module()` decorator metadata), but additionally - depending on the **entities and options** objects passed into the `forRoot()` method - exposes a collection of providers, for example, **repositories**.

- The `DatabaseModule` can be imported and configured in the following manner:

```javascript
import { Module } from '@nestjs/common';

import { DatabaseModule } from 'core/database/database.module';
import { User } from 'modules/user/user.entity.ts';
import { Product } from 'modules/product/product.entity.ts';

@Module({
  imports: [
    DatabaseModule.forRoot([User, Product], {
      type: 'postgres',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'password',
      database: 'mydatabase',
    }),
  ],
})
export class AppModule {}
```

## Conclusion

- Understanding and effectively utilizing modules in **NestJS** is essential for building **scalable and maintainable** applications.
- Whether organizing feature-specific code, sharing providers, optimizing global functionality, or dynamically configuring modules, **NestJS** modules offer a robust foundation for application development.

## References

- [Overview Modules In NestJS](https://docs.nestjs.com/modules)
- [Fundamentals - Dynamic modules](https://docs.nestjs.com/fundamentals/dynamic-modules)

Happy reading! <Twemoji emoji="clinking-beer-mugs" />
